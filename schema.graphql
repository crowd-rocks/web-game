# Indicates exactly one field must be supplied and this field must not be `null`.
directive @oneOf on INPUT_OBJECT

type Group {
  groupId: ID!
  name: String!
  createdBy: ID!
  createdAt: DateTime!
}

# A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
scalar DateTime

type GroupMembership {
  groupMembershipId: ID!
  groupId: ID!
  userId: ID!
  memberType: GroupMemberType!
  createdBy: ID!
  createdAt: DateTime!
}

# The type of membership a user has in a group
enum GroupMemberType {
  NONE
  OWNER
  SUPER_ADMIN
  ADMIN
  MODERATOR
  MEMBER
}

type Avatar {
  avatarId: ID!
  userId: ID!
  name: String!
  publicState: String
  privateState: String
  createdAt: DateTime!
}

type ChunkCoordinates {
  x: BigInt!
  y: BigInt!
  z: BigInt!
}

type VoxelCoordinates {
  x: Int!
  y: Int!
  z: Int!
}

type Actor {
  actorId: ID!
  mapId: ID!
  userId: ID!
  avatarId: ID!
  uuid: String!
  chunk: ChunkCoordinates!
  privateState: String
  publicState: String
  createdAt: DateTime!
}

type Map {
  mapId: ID!
  name: String
  owner: ID
  states: String
  createdAt: DateTime!
}

type UserMapState {
  userId: ID!
  mapId: ID!
  state: String
  createdAt: DateTime!
  updatedAt: DateTime!
  map: Map
}

type User {
  userId: ID!
  email: String!
  gamertag: String
  disambiguation: String
  state: String
  isConfirmed: Boolean!
  createdAt: DateTime!
}

type UserDonationData {
  totalAmountCents: String!
  currency: String!
}

type UserPropertyTokenData {
  available: String!
  inUse: String!
  total: String!
}

type AvatarDTO {
  avatarId: ID!
  userId: ID!
  name: String!
  publicState: String
  privateState: String
  createdAt: DateTime!
}

type TeleportResponse {
  success: Boolean!
  errorCode: ErrorType!
}

# The type of error that can occur in the application
enum ErrorType {
  NO_ERROR
  UNKNOWN_ERROR
  EMAIL_NOT_FOUND
  BAD_PASSWORD
  EMAIL_ALREADY_EXISTS
  INVALID_TOKEN
  MAP_NOT_FOUND
  UNAUTHORIZED
  MAP_NOT_LOADED
  EMAIL_TOO_SHORT
  EMAIL_TOO_LONG
  PASSWORD_TOO_SHORT
  PASSWORD_TOO_LONG
  GAME_TOKEN_WRONG_SIZE
  NAME_TOO_LONG
  INVALID_REQUEST
  EMAIL_INVALID
  INVALID_TOKEN_LENGTH
  INVALID_MAP_ID
  CHUNK_NOT_FOUND
  USER_NOT_AUTHENTICATED
  INVALID_STATE_DATA
  USER_NOT_APP_ADMIN
  GRID_OUTSIDE_ASSIGNMENT
  NO_MATCHING_GRID_ASSIGNMENT
  INVALID_GRID_COORDINATES
  GRID_ALREADY_EXISTS
  GRID_OVERLAPS_EXISTING
  GAMERTAG_ALREADY_EXISTS
}

type AuthResponse {
  token: String!
  gameTokenId: String!
  user: User!
}

type ServerStatus {
  serverId: ID!
  ip4: String!
  ip6: String!
  clientPort: Int!
  status: ServerState!
  peers: Int!
  clients: Int!
  updatedAt: DateTime!
  createdAt: DateTime!
}

# The current state of the server
enum ServerState {
  Starting
  ReadyForClients
  Stopping
  Offline
}

type VersionInfo {
  # Major version number
  major: Int!

  # Minor version number
  minor: Int!

  # Patch version number
  patch: Int!

  # Build number
  build: Int!
}

type ServerVersionInfo {
  # Current server version
  serverVersion: VersionInfo!

  # Minimum accepted client version
  minimumClientVersion: VersionInfo!
}

type VoxelState {
  voxelCoord: VoxelCoordinates!
  voxelType: Int!
  state: String
}

type LodData {
  level: Int!
  data: String!
}

type Chunk {
  chunkId: ID!
  mapId: ID!
  coordinates: ChunkCoordinates!
  voxels: String
  voxelStates: [VoxelState!]!
  owner: ID
  createdAt: DateTime!
  updatedAt: DateTime!
  chunkState: String
  cdnUploadedAt: DateTime
  lods: [LodData!]
}

type Voxel {
  voxelUpdateId: BigInt!
  mapId: BigInt!
  coordinates: ChunkCoordinates!
  location: VoxelCoordinates!
  voxelType: Int!
  state: String
  createdBy: BigInt!
  createdAt: DateTime!
}

type ChunkVoxelResponse {
  coordinates: ChunkCoordinates!
  voxels: [Voxel!]!
}

type ChunkLodsResponse {
  chunkId: ID!
  mapId: ID!
  coordinates: ChunkCoordinates!
  lods: [LodData!]!
  updatedAt: DateTime!
}

type ChunksByDistanceResponse {
  chunks: [Chunk!]!
  limit: Int
  skip: Int
}

type ChunkVoxelUpdatesResponse {
  coordinates: ChunkCoordinates!
  voxels: [Voxel!]!
}

type VoxelUpdatesByDistanceResponse {
  chunks: [ChunkVoxelUpdatesResponse!]!
  limit: Int
  skip: Int
}

type Grid {
  grid_id: BigInt!
  app_id: BigInt!
  map_id: BigInt!
  low_chunk: ChunkCoordinates!
  high_chunk: ChunkCoordinates!
  created_at: DateTime!
}

type CreateGridResponse {
  grid: Grid
  error: ErrorType!
}

type PaymentLinkOutput {
  url: String!
  id: String!
  type: String!
  amountCents: Float
  currency: String
  createdAt: DateTime!
  expiresAt: DateTime
}

# BigInt custom scalar type. Input should be a string representation of a BigInt.
scalar BigInt

type Query {
  me: User
  user(id: BigInt!): User
  myDonationData: UserDonationData!
  myPropertyTokens: UserPropertyTokenData!
  users: [User!]!
  usersByGamertag(gamertag: String!): [User!]!
  usersByEmail(email: String!): [User!]!
  userAvatars(userId: BigInt!): [Avatar!]!
  avatar(id: BigInt!): Avatar!
  actor(id: BigInt!): Actor!
  actors(filter: ActorFilterInput): [Actor!]!
  userMapState(mapId: BigInt!): UserMapState
  userMapStates: [UserMapState!]!
  myAvatars: [AvatarDTO!]!

  # Returns the server with the least number of connected clients
  serverWithLeastClients: ServerStatus!

  # Returns version information for the server and minimum client version requirements
  versionInfo: ServerVersionInfo!
  groups: [Group!]!
  group(id: BigInt!): Group!
  groupMemberships(groupId: BigInt!): [GroupMembership!]!
  userGroupMemberships(userId: BigInt!): [GroupMembership!]!
  getChunk(input: GetChunkInput!): Chunk
  getChunkLods(input: GetChunkLodsInput!): ChunkLodsResponse
  getVoxelList(input: GetVoxelListInput!): ChunkVoxelResponse!
  getChunksByDistance(
    input: GetChunksByDistanceInput!
  ): ChunksByDistanceResponse!
  listVoxels(input: ListVoxelsInput!): [Voxel!]!
  listVoxelUpdatesByDistance(
    input: ListVoxelUpdatesByDistanceInput!
  ): VoxelUpdatesByDistanceResponse!
  getMyPaymentLinks: [PaymentLinkOutput!]!
}

input ActorFilterInput {
  mapId: BigInt
  avatarId: BigInt
  uuid: String
  chunk: ChunkCoordinatesInput
}

input ChunkCoordinatesInput {
  x: BigInt!
  y: BigInt!
  z: BigInt!
}

input GetChunkInput {
  mapId: BigInt!
  coordinates: ChunkCoordinatesInput!
  requestedLodLevels: [Int!]
  includeAllLods: Boolean
}

input GetChunkLodsInput {
  mapId: BigInt!
  coordinates: ChunkCoordinatesInput!
  lodLevels: [Int!]!
}

input GetVoxelListInput {
  mapId: BigInt!
  coordinates: ChunkCoordinatesInput!
}

input GetChunksByDistanceInput {
  mapId: BigInt!
  centerCoordinate: ChunkCoordinatesInput!
  maxDistance: Int!
  limit: Int
  skip: Int
}

input ListVoxelsInput {
  mapId: BigInt!
  coordinates: ChunkCoordinatesInput!
  since: DateTime
}

input ListVoxelUpdatesByDistanceInput {
  mapId: BigInt!
  centerCoordinate: ChunkCoordinatesInput!
  maxDistance: Int!
  limit: Int
  skip: Int
  since: DateTime
}

type Mutation {
  updateGamertag(input: UpdateGamertagInput!): User!
  createAvatar(input: CreateAvatarInput!): Avatar!
  updateAvatar(id: BigInt!, input: UpdateAvatarInput!): Avatar!
  deleteAvatar(id: BigInt!): Avatar!
  createActor(input: CreateActorInput!): Actor!
  updateActor(id: BigInt!, input: UpdateActorInput!): Actor!
  deleteActor(id: BigInt!): Actor!
  updateUserState(input: UpdateUserStateInput!): User!
  updateAvatarState(id: BigInt!, input: UpdateAvatarStateInput!): Avatar!
  updateActorState(id: BigInt!, input: UpdateActorStateInput!): Actor!
  updateUserMapState(input: CreateUserMapStateInput!): UserMapState!
  deleteUserMapState(mapId: BigInt!): UserMapState!
  teleportRequest(input: TeleportRequestInput!): TeleportResponse!
  login(loginUserInput: LoginUserInput!): AuthResponse!
  register(registerUserInput: RegisterUserInput!): AuthResponse!
  confirmEmail(token: String!): Boolean!
  requestPasswordReset(email: String!): Boolean!
  resetPassword(resetPasswordInput: ResetPasswordInput!): Boolean!
  resendConfirmationEmail(email: String!): Boolean!
  logout: Boolean!
  changePassword(currentPassword: String!, newPassword: String!): Boolean!
  logoutAllDevices: Boolean!
  createGroup(createGroupInput: CreateGroupInput!): Group!
  updateGroup(id: BigInt!, updateGroupInput: UpdateGroupInput!): Group!
  updateChunk(input: ChunkUpdateInput!): Chunk!
  updateChunkState(input: UpdateChunkStateInput!): Chunk
  updateChunkLods(input: UpdateChunkLodsInput!): Chunk
  updateVoxel(input: UpdateVoxelInput!): Voxel!
  createGrid(input: CreateGridInput!): CreateGridResponse!
  createPaymentLink(input: CreatePaymentLinkInput!): PaymentLinkOutput!
}

input UpdateGamertagInput {
  gamertag: String!
  disambiguation: String!
}

input CreateAvatarInput {
  name: String
}

input UpdateAvatarInput {
  name: String
}

input CreateActorInput {
  mapId: BigInt!
  avatarId: BigInt!
  uuid: String!
  chunk: ChunkCoordinatesInput!
  privateState: String
  publicState: String
}

input UpdateActorInput {
  mapId: BigInt
  avatarId: BigInt
  uuid: String
  chunk: ChunkCoordinatesInput
  privateState: String
  publicState: String
}

input UpdateUserStateInput {
  state: String
}

input UpdateAvatarStateInput {
  publicState: String
  privateState: String
}

input UpdateActorStateInput {
  privateState: String
  publicState: String
}

input CreateUserMapStateInput {
  mapId: BigInt!
  state: String
}

input TeleportRequestInput {
  mapId: BigInt!
  chunkAddress: ChunkCoordinatesInput!
  voxelAddress: VoxelCoordinatesInput!
  UUID: String!
}

input VoxelCoordinatesInput {
  x: Int!
  y: Int!
  z: Int!
}

input LoginUserInput {
  email: String!
  password: String!
}

input RegisterUserInput {
  email: String!
  password: String!
  gamertag: String
}

input ResetPasswordInput {
  token: String!
  newPassword: String!
}

input CreateGroupInput {
  name: String!
}

input UpdateGroupInput {
  name: String
  description: String
}

input ChunkUpdateInput {
  mapId: BigInt!
  coordinates: ChunkCoordinatesInput!
  voxels: String
  voxelStates: [VoxelStateInput!]
}

input VoxelStateInput {
  voxelCoord: VoxelCoordinatesInput!
  voxelType: Int!
  state: String
}

input UpdateChunkStateInput {
  mapId: BigInt!
  coordinates: ChunkCoordinatesInput!
  chunkState: String
}

input UpdateChunkLodsInput {
  mapId: BigInt!
  coordinates: ChunkCoordinatesInput!
  lods: [LodDataInput!]!
}

input LodDataInput {
  level: Int!
  data: String!
}

input UpdateVoxelInput {
  mapId: BigInt!
  coordinates: ChunkCoordinatesInput!
  location: VoxelCoordinatesInput!
  voxelType: Float!
  state: String
}

input CreateGridInput {
  app_id: BigInt!
  corner1: ChunkCoordinatesInput!
  corner2: ChunkCoordinatesInput!
}

input CreatePaymentLinkInput {
  type: PaymentLinkType!
  appId: String
  successUrl: String
  cancelUrl: String
}

# The type of payment link to create (donations or property tokens)
enum PaymentLinkType {
  DONATION
  PROPERTY_TOKENS
}
